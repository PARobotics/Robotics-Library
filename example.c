#pragma config(Sensor, in1,    G_SENSOR,       sensorGyro)
#pragma config(Sensor, in2,    PWR,            sensorPotentiometer)
#pragma config(Sensor, in3,    ACC_X,          sensorAccelerometer)
#pragma config(Sensor, in4,    ACC_Y,          sensorAccelerometer)
#pragma config(Sensor, in5,    ACC_Z,          sensorAccelerometer)
#pragma config(Sensor, in6,    DUMP_ANGLE,     sensorPotentiometer)
#pragma config(Sensor, in7,    LIFT_POT,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  WHEEL_R,        sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  WHEEL_L,        sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  P_TRANS,        sensorDigitalOut)
#pragma config(Sensor, dgtl10, P_CLAW_R,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, P_CLAW_L,       sensorDigitalOut)
#pragma config(Sensor, dgtl12, P_LIFT,         sensorDigitalOut)
#pragma config(Motor,  port1,           M_DRV_FL,      tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           M_DUMP_R3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           M_DRV_BL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           M_DUMP_L1,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           M_DUMP_L2,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           M_DUMP_R2,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           M_DUMP_R1,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           M_DRV_BR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           M_DUMP_L3,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          M_DRV_FR,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// -- only task running with usercontrol is motorCtrl/SlewRate
//    mv PB task as function instead of task
//    stop all other dump, lift, monitor functions -- create a customized function for carry
// -- increase the DT for usercontrol (to 10 or as long as possible that still control remote smoothly)
#pragma DebuggerWindows("debugStream")

#pragma platform(VEX)
#pragma competitionControl(Competition)
//#pragma competitionControl(OFF)
#pragma autonomousDuration(20)
#pragma userControlDuration(1200)
#include "Vex_Competition_Includes.c"

// include functions from Libs (the always reusable code)
#include "Libs\FuncLib.c"     // basic functions
#include "Libs\Pid.c"         // pid functions
// -- Motorlib (slew rate control, timeout, bailout)
#define MOTOR_USE_SLEW          1     //
int MOTOR_SLEW[10] =  { 15, 15, 15, 15, 15, 15, 15, 15, 15, 15 };  // has to match motor numbers
#define MOTOR_SLEW_DELAY        20     //

#define WAIT_DT_USERCONTROL 10
#define TURNON  1
#define TURNOFF 0
#define USE_PR_AS_TASK 0       // if ==1; run as a task -- backward compatible
                               // if ==0; only run as function (inside usercontrol task)

//void bailout(); //Defined first, body filled later
#include "Libs/MotorCtrl.c"
// -- Push-release buttons
const int NUM_PR_BUTTONS = 8;    // define how many buttons to monitor as PR buttons
#define PR_Btn7U 0
// #define PR_Btn7R 1
#define PR_Btn7D 1
#define PR_Btn7L 2
#define PR_Btn8L 3
#define PR_Btn8U 4
#define PR_Btn8R 5
#define PR_Btn8D 6
#define PR_Btn5U 7
#include "Libs\PR_Button.c"     // include source file

// include ss specific files -- order matters
#include "ss.h"                 // head file
#include "ss_func.c"            // very basic functions -- is_bailout, is_timeout, battery ,...
#include "ss_lcd.c"             // lcd functions
#include "ss_monitor.c"         // sensor monitoring functions and task -- all sensor value codes be here
#include "ss_dump.c"            // dump functions and task
#include "ss_move.c"            // movement functions and task
#include "ss_lift.c"            // lift functions and task
#include "ss_auton.c"           // auton, skills, and complex movements


// use different slew for driving and skills/auton
void set_slew(int opt) {
  if (opt==TURNON) {            // for user_ctrl
    for ( unsigned  int i=0;i<10;i++) {
      MOTOR_SLEW[i] = 15;
    }
  }
  else if (opt==TURNOFF) {     // for auton and skills
    // no slew for dumper
    MOTOR_SLEW[1] = 255;
    MOTOR_SLEW[8] = 255;
    MOTOR_SLEW[3] = 255;
    MOTOR_SLEW[4] = 255;
    MOTOR_SLEW[5] = 255;
    MOTOR_SLEW[6] = 255;
    // make wheels twice as faster
    MOTOR_SLEW[0] = 30;
    MOTOR_SLEW[2] = 30;
    MOTOR_SLEW[7] = 30;
    MOTOR_SLEW[9] = 30;
  }
}

void switch_to_skills() {
  // start tasks need for skills and set global variables corretly
  set_slew(TURNOFF);
  startTask(ss_monitor, 9);
  /*startTask(ss_dump, 9);
  startTask(ss_lift, 9);*/
  WHEEL_MONITOR = START;
  DUMP_MONITOR = START;
}

void switch_to_usercontrol() {
  // stop tasks for user controls and set global variables correctly
  set_slew(TURNON);
  stopTask(ss_monitor);
  stopTask(ss_dump);
  stopTask(ss_lift);
  WHEEL_MONITOR = STOP;
  DUMP_MONITOR = STOP;
}

/*
PRE AUTONOMOUS
functions
*/

void sensor_reset() {
	SensorValue(ACC_X) = 0;
	SensorValue(ACC_Y) = 0;
	SensorValue(ACC_Z) = 0;
	SensorValue(G_SENSOR) = 0;
	SensorValue(WHEEL_L) = 0;
	SensorValue(WHEEL_R) = 0;
  wait1Msec(2000);    // necessary for gyro calibration
}

void global_variable_reset() {

}

void pre_auton(){

  clearTimer(T1);
  sensor_reset();
  global_variable_reset();
  wheel_init();

  claw(CLOSE);

  //LCD
  lcd_selection();
  lcd_msg_init();

  //we only start MotorSlewRateTask
  startTask(MotorSlewRateTask, 7);
  startTask(ss_lift, 7);
  startTask(ss_dump, 7);
]
}

/*
 	AUTONOMOUS
	task
]*/

task autonomous(){
  autonProcedure();
}

/*
	USER CONTROL
*/

task usercontrol(){
  int tnow;
  int tlast=time1[T1];

	//Make sure auton is off
  stopTask( autonomous );
  // switch to skills to prepare for auton
  switch_to_usercontrol();

	#if DEBUG == YES
	  writeDebugStreamLine("usercontrol");
	#endif

  // use default slew protection
  set_slew(TURNON);
  wait1Msec(10);    // create a diff between tnow and tlast


	int V, H;

	//DUMP_MONITOR = START; //Update dumper values
  // if we are doing drving skills, we will first run
  // prg_mv1 and prg_mv2 (only breakable by 7D)
  // make sure it matches ss_auto prgskills
  if (MODE == RBT_SKILL) {
    switch_to_skills();
    wheel_reset(-SIDE*360, 200, ang_side(-900));
    // initial movement - 4 stars 2 cube
    prg_mv1();
    prg_mv2();
    switch_to_usercontrol();

  }

	while (true) {
    tnow = time1[T1];
    ///////////////////////////////////////////////////////
    // Controls for all modes
    ///////////////////////////////////////////////////////

    // check PR Button status if not run as a task
#if USE_PR_AS_TASK==0
    update_prb_status();
#endif

    // handling of dump functions used to be in dump task
  	getDumpVal();
    if(DUMP_VAL > DUMP_RELEASE) claw(OPEN); //Release claw at a certain value
    if (DUMP_COMMAND==CARRY_USERCONTROL) {
      DUMP_OMEGA = (DUMP_VAL - DUMP_LAST_VAL) * 1000 * 60 / 360 / (tnow - tlast); // .1
      dump_carry_usercontrol();
      DUMP_LAST_VAL = DUMP_VAL;     // stash dump_last_val
    }

		/*
			DRIVING CONTROL
		*/
		V = vexRT[Ch3];
		H = vexRT[Ch1];
		//Prevent against Small Motions

		if (abs(V) < MOTION_DRV_THRESHOLD) V = 0;
		if (abs(H) < MOTION_DRV_THRESHOLD) H = 0;
		move(V, H * 0.75);
    // Shall we change to Truespeed???

		/*
			DUMPER CONTROL
      some Dumper controls only if transmission is set
		*/

		//Dumper control only if transmission is set
    // -- if Btn-5D is pushed, try to upper arm (otherwise will not move)
		if(vexRT[Btn6U] == 1){
			// if(SensorValue(P_TRANS) == 0) DUMP_COMMAND = UP;
			if(SensorValue(P_TRANS) == 0) {
        if(DUMP_VAL < DUMP_MAX) {
          dumper(127);
          DUMP_COMMAND = UP;
        }
        else {
          dumper(0);
          DUMP_COMMAND = STOP;
        }
      }
		}
    // -- if Btn-5D is pushed, try to lower arm (otherwise will not move)
		else if(vexRT[Btn6D] == 1){
			// if(SensorValue(P_TRANS) == 0) DUMP_COMMAND = DOWN;
			if(SensorValue(P_TRANS) == 0) {
        dumper(-127);
        DUMP_COMMAND = DOWN;
      }

		}
		// else if(vexRT[Btn5UXmtr2] == 1){
			// DUMP_COMMAND = MANUAL_UP;
		// }
		// else if(vexRT[Btn5DXmtr2] == 1){
			// DUMP_COMMAND = MANUAL_DOWN;
		// }
		else if(DUMP_COMMAND != CARRY_USERCONTROL && DUMP_COMMAND != CARRY && DUMP_COMMAND != PRG && DUMP_COMMAND != HOLD && DUMP_COMMAND != WIGGLE){
			DUMP_COMMAND = STOP;
      dumper(0);
		}

		// if((vexRT[Btn5D] == 1) && (SensorValue(P_TRANS) == 0) ) DUMP_COMMAND = HOLD;
		if((vexRT[Btn5D] == 1) && (SensorValue(P_TRANS) == 0) ) dump_hold_usercontrol();

 // -- if PR-Btn7L is pushed, do one dump and get out at 120 deg
    // if ((get_pr_button(PR_Btn7L) == 1) && (SensorValue(P_TRANS) == 0)) {
			// one_dump(1200, 1000, 750);
      // DUMP_COMMAND = HOLD;
      // reset_pr_button(PR_Btn7L);
		// }
    // -- if PR-Btn8U is pushed, claw close and set to CARRY
    if ((get_pr_button(PR_Btn5U) == 1) && (SensorValue(P_TRANS) == 0)) {
      claw(CLOSE);
      wait1Msec(50);
      // DUMP_COMMAND = CARRY;
      DUMP_COMMAND = CARRY_USERCONTROL;
      reset_pr_button(PR_Btn5U);
		}

		/*
			CLAW
		*/
    if (get_pr_button(PR_Btn8D) == 1) {
			claw(TOGGLE);
      DUMP_COMMAND = STOP;     // no more carry holding
      reset_pr_button(PR_Btn8D);
		}

		/*
			LIFT CONTROL
		*/
    if (get_pr_button(PR_Btn8L) == 2) {
			//Toggle transmission -- has to hold on the button
      //startTask(ss_dump, 9);   // need to be careful if click the button multiple times will it be a problem???
      wait1Msec(20);
			transmission(TOGGLE);
      reset_pr_button(PR_Btn8L);
		}

    if (MODE != TESTING && get_pr_button(PR_Btn8R) == 1) {
			//Put piston up
      SensorValue(P_LIFT) = 1;
      wait1Msec(500);
      SensorValue(P_LIFT) = 0;
      reset_pr_button(PR_Btn8R);
		}


    // add a special PB button for robot skills -- carry hight
    /*if ((MODE == RBT_SKILL) && (get_pr_button(PR_Btn7U) == 1) && (SensorValue(P_TRANS) == 0)) {
      DUMP_COMMAND = CARRY_HIGH;
      reset_pr_button(PR_Btn7U);
		}*/

    //Lift control only if transmission is set
		if(vexRT[Btn7U] == 1){
			if(SensorValue(P_TRANS) == 1) {
				SensorValue(P_LIFT) = 1;
      	dumper(-127);
			}
		}
		else if(vexRT[Btn7D] == 1){
			if(SensorValue(P_TRANS) == 1){
				SensorValue(P_LIFT) = 0;
      	dumper(127);
			}
		}
		else if(vexRT[Btn6UXmtr2] == 1){
			LIFT_COMMAND = MANUAL_UP;
		}
		else if(vexRT[Btn6DXmtr2] == 1){
			LIFT_COMMAND = MANUAL_DOWN;
		}
		else{
			dumper(0);
		}

		if(vexRT[Btn8UXmtr2] == 1){
			SensorValue(P_LIFT) = 1;
		}
		if(vexRT[Btn8DXmtr2] == 1){
			SensorValue(P_LIFT) = 0;
		}

		///////////////////////////////////////////////////////
    // Controls for testing mode
    ///////////////////////////////////////////////////////

    if (MODE == TESTING) {
      // in testing model Btn8R test all 6 dump motors
      int waitT1 , waitT2 , vcmd;
    	// if(get_pr_button(PR_Btn7R) == 1){
    	if(get_pr_button(PR_Btn8U) == 1){
        waitT1 = 1000;
        waitT2 = 500;
        vcmd   = 127;
        motorReq[M_DRV_FL] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_FL] = 0; wait1Msec(waitT2);
        motorReq[M_DRV_BL] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_BL] = 0; wait1Msec(waitT2);
        motorReq[M_DRV_FR] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_FR] = 0; wait1Msec(waitT2);
        motorReq[M_DRV_BR] = vcmd; wait1Msec(waitT1);	motorReq[M_DRV_BR] = 0; wait1Msec(waitT2);
        reset_pr_button(PR_Btn8U);
        // reset_pr_button(PR_Btn7R);
      }
    	if(get_pr_button(PR_Btn8R) == 1){
        DUMP_COMMAND = PRG;   // make sure don't mess up DUMP_COMMAND
        waitT1 = 100;
        waitT2 = 500;
        vcmd   = 60;
        motorReq[M_DUMP_L1] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_L1] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_L2] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_L2] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_L3] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_L3] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_R1] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_R1] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_R2] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_R2] = 0; wait1Msec(waitT2);
        motorReq[M_DUMP_R3] = vcmd; wait1Msec(waitT1);	motorReq[M_DUMP_R3] = 0; wait1Msec(waitT2);
        // DUMP_COMMAND = STOP;
        dumper(0);
        reset_pr_button(PR_Btn8R);
      }
      if(get_pr_button(PR_Btn8L) == 1){
        switch_to_skills();
        // test auto_a()
        prg_skills();
        //LIFT_MONITOR = START;
				reset_pr_button(PR_Btn8L);
        switch_to_usercontrol();
    	}

    	if(get_pr_button(PR_Btn8D) == 1){
        switch_to_skills();
        // prg_skills();
        // DUMP_MONITOR = STOP;
        // WHEEL_MONITOR = STOP;

        /////// task 3 -- collect lift data; video and data needed to fine tune lift data
        // explore a better move for self alignment,


        /////// task 4 -- collect lift data and video
        // transmission(CLOSE);
        // wait1Msec(300);
        // if(DUMP_VAL < DUMP_RELEASE) dump_wiggle();
        // go_lift();

        /////// task 1 -- collect  data and video from mv 1 and 2
        // wheel_reset(-360, 200, -900); // test prg_mv1
        // prg_mv1();
        // prg_mv2();

        /////// task 2 -- collect  data and video from mv 1 and 2
        // wheel_reset(400, 660, -900);
        // prg_mv3();
        // prg_mv4();


        /////// task 5 -- fi have time and already concluded no other better options for alignment

        // wheel_reset(450, 660, -900);
        // prg_mv5();
        // wait1Msec(100);
        switch_to_usercontrol();
        reset_pr_button(PR_Btn8D);
      }

    }

		lcd_message();    // do we need to update LCD message in driving, maybe turn it off???
    tlast = tnow;     // update time
		wait1Msec(WAIT_DT_USERCONTROL);
		//wait1Msec(10);
	}
}
